import asyncio
import random
import warnings
from fastmcp import Client


class OsworldMcpClient:
    config = {
        "mcpServers": {
            "osworld_mcp": {
                "url": "http://localhost:9292/mcp",
                "transport": "streamable-http"
            },
            "filesystem": {
                "command": "npx",
                "args": [
                    "-y",
                    "@modelcontextprotocol/server-filesystem",
                    "/home/user",
                ]
            },
            "git": {
                "command": "uvx",
                "args": ["mcp-server-git"]
            }
        }
    }

    # -----------------------------
    # Internal helper: run safely
    # -----------------------------
    @staticmethod
    def _run(coro):
        """Run a coroutine safely and suppress closed-loop warnings."""
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = None

        if loop and loop.is_running():
            return asyncio.run_coroutine_threadsafe(coro, loop).result()

        # Suppress “Event loop is closed” cleanup warnings
        warnings.filterwarnings("ignore", category=RuntimeWarning, message=".*Event loop is closed.*")

        # Use a dedicated loop and explicit shutdown
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(coro)
        finally:
            # Cleanly close asynchronous generators and transports
            loop.run_until_complete(loop.shutdown_asyncgens())
            try:
                loop.run_until_complete(loop.shutdown_default_executor())
            except Exception:
                pass
            loop.close()
            asyncio.set_event_loop(None)

    # -----------------------------
    # Async methods
    # -----------------------------
    @classmethod
    async def _list_tools_async(cls, tool_name=None, shuffle=False, rag=True):
        async with Client(cls.config) as client:
            tool_list = await client.list_tools()
            tool_list = [{
                "name": tool.name,
                "description": tool.description,
                "parameters": tool.inputSchema
            } for tool in tool_list]

        if not rag:
            return tool_list

        # Filter or fallback logic
        result = [t for t in tool_list if tool_name and tool_name in t["name"]]
        if not result:
            exclude_apps = [
                "libreoffice_calc",
                "libreoffice_impress",
                "libreoffice_writer",
                "code",
                "vlc",
                "google_chrome",
                "thunderbird",
            ]
            for t in tool_list:
                if not any(ex in t["name"] for ex in exclude_apps):
                    result.append(t)

        if shuffle:
            random.shuffle(result)
        return result

    @classmethod
    async def _call_tool_async(cls, name, params=None):
        async with Client(cls.config) as client:
            return await client.call_tool(name, params or {})

    # -----------------------------
    # Public entrypoints
    # -----------------------------
    @classmethod
    def list_tools(cls, tool_name=None, shuffle=False, rag=True):
        tools = cls._run(cls._list_tools_async(tool_name, shuffle, rag))
        print(tools)
        return tools

    @classmethod
    def call_tool(cls, name, params=None):
        result = cls._run(cls._call_tool_async(name, params))
        print(result)
        return result


# -----------------------------
# Example usage
# -----------------------------
if __name__ == "__main__":
    OsworldMcpClient.call_tool(
        "VSCodeTools_search_text",
        {"text": "files"}
    )
