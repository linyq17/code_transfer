import asyncio
from fastmcp import Client
import random
import platform


class OsworldMcpClient:
    config = {
        "mcpServers": {
            "osworld_mcp": {
                "url": "http://localhost:6666/mcp",
                "transport": "streamable-http"
            },
            "filesystem": {
                "command": "npx",
                "args": [
                    "-y",
                    "@modelcontextprotocol/server-filesystem",
                    "/home/user",
                ]
            },
            "git": {
                "command": "uvx",
                "args": [
                    "mcp-server-git"
                ]
            }
        }
    }
    
    @classmethod
    def _get_or_create_event_loop(cls):
        """Get existing event loop or create a new one if needed."""
        try:
            loop = asyncio.get_event_loop()
            if loop.is_closed():
                raise RuntimeError("Event loop is closed")
            return loop
        except RuntimeError:
            # Create new event loop if none exists or current one is closed
            if platform.system() == 'Windows':
                loop = asyncio.ProactorEventLoop()
                asyncio.set_event_loop(loop)
            else:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
            return loop
    
    @classmethod
    def _run_async(cls, coro):
        """Safely run async coroutine."""
        loop = cls._get_or_create_event_loop()
        try:
            return loop.run_until_complete(coro)
        except Exception as e:
            print(f"Error running async operation: {e}")
            raise
    
    @classmethod
    def list_tools(cls, tool_name, shuffle=False, rag=True):
        async def _list_tools():
            client = Client(cls.config,roots=['file:///home/user'])
            async with client:
                tool_list = await client.list_tools()
                tool_list = [{
                    "name": tool.name,
                    "description": tool.description,
                    "parameters": tool.inputSchema
                } for tool in tool_list
                ]
            
            if rag:
                # filter
                result = []
                for tool in tool_list:
                    if (tool_name is not None) and (tool_name in tool['name']):
                        result.append(tool)
                
                exclude_apps = [
                    "libreoffice_calc",
                    "libreoffice_impress",
                    "libreoffice_writer",
                    "code",
                    "vlc",
                    "google_chrome",
                    "thunderbird",
                ]
                
                if len(result) == 0:
                    for tool in tool_list:
                        skip = False
                        for exclude_app in exclude_apps:
                            if exclude_app in tool['name']:
                                skip = True
                        if not skip:
                            result.append(tool)
                return result
            else:
                return tool_list
        
        tool_list = cls._run_async(_list_tools())
        
        if shuffle:
            random.shuffle(tool_list)
        
        print(tool_list)
        return tool_list
    
    @classmethod
    def call_tool(cls, name, params={}):
        async def _call_tool():
            client = Client(cls.config,roots=['file:///home/user'])
            async with client:
                response = await client.call_tool(
                    name,
                    params
                )
            return response
        
        response = cls._run_async(_call_tool())
        print(response)
        return response
